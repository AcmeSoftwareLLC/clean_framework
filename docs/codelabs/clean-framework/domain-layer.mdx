# The Domain Layer

## Exploring the Domain Layer
Welcome to the heart of your project â€“ the Domain Layer. This is where all of your core business-logic resides.

<Image src="/assets/domain_layer.png" caption="Domain Layers"/>

### Entities: The Core Components
Entities are the building blocks of your app's state, existing as long as their respective Use Cases do. Here are some guidelines for creating robust entities:
1. **Independence**: Entities should only depend on the clean framework import and not on external libraries or other features. Since the Entity layer is the innermost of all the Clean Architecture layers, it shouldn't depend on anything!
2. **Immutability**: Attributes should be final, with initial values set during construction. They can also be required, being given values at Use Case creation. This will be explained further in the next section.
3. **Data Types**: Use proper data types (e.g., DateTime instead of String for dates) instead of relying on parsers. Parsing can be done in Presenters or Gateways.
4. **Hierarchy and Composition**: It is OK to create a hierarchy of entities, but keep a single ancestor that the Use Case can create easily. Prefer composition over inheritance. Utilize constructs like Either and Unions for flexibility.
5. **Convenience Methods**: Implement generator methods like `copyWith` for easy state management. This simplifies writing code in the Use Case.

#### Entity Example:
```dart

class AccountEntity extends Entity {
  AccountEntity({this.isRegistered = false, this.userName});

  final bool isRegistered;
  final UserNameEntity? userName;
}

class UserNameEntity extends Entity{
  UserNameEntity({required this.firstName, required this.lastName})
    : assert(firstName.isNotEmpty && lastName.isNotEmpty);

  final String firstName;
  final String lastName;

  String get fullName => '$firstName $lastName';
}
```

In this example, note that it is nearly impossible for a developer to create an inconsistent username with null or empty data (e.g. first or last name). It is alright to add methods to validate the consistency of the data, or methods such as dynamic getters that retrieve data from multiple fields.

This has a few advantages:

1. It's like a safety net for developers. By catching syntax errors or exceptions early on, you're less likely to write incorrect code around these entity fields. This makes testing and coding a smoother process.

2. It keeps things organized. Instead of mixing up custom logic for composing fields with the Use Case's business logic, we're assigning it to the Entity. This makes your Use Case code cleaner and easier to understand.

Pro tip: Offload those helper methods to the Entity, especially when they're just working with data. This includes stuff like form validations, math calculations, and so on. It's all about keeping it neat and tidy!

<aside class="negative">
Remember to ensure that only relevant logic is included in the Entities, and avoid incorporating behavior that should be part of the Use Case. Always consider whether your method remains useful even if other layers change or are removed, adhering to the principles of layer separation.
</aside>

**What's a Use Case?**
Use Cases sit outside Entities, in their own layer. They're all about managing Entities and moving data between Inputs and Outputs. Let's jump into an example to make this clearer:

```dart
class MyUseCase extends UseCase<MyEntity> {
  MyUseCase()
      : super(
          entity: MyEntity(),
          transformers: [
            OutputTransformer.from(
              (entity) => MyUIOutput(data: entity.data),
            ),
            InputTransformer<MyEntity, MyInput>.from(
              (entity, input) => entity.copyWith(data: input.data),
            ),
          ],
        );
}
```

In any given Use Case, you'll need to create an Entity. You can also set up input and output filters as shown above, which are essentially different "channels" that Presenters subscribe to for updates.

Let's take the example of `MyUseCase`, which has a single output. In this case, the Presenter only needs to tune into updates from `MyUIOutput` instances. These instances are generated when the Presenter is initialized and anytime there's a change in the Entity's **data** field .

The filtering mechanism is pretty straightforward. It uses a Map that associates an Output type with a function that processes the current Entity instance. This approach simplifies the coding process, helping developers focus on straightforward logic and avoid complex method calls.

It's important to note that Outputs are designed to contain only a portion of the Entity's data. The Presenter and Use Case communicate in such a way that a new Output is generated **only** if there's a change in the specific fields used to create it. For instance, even if `MyUseCase` modifies the Entity, no new Output will be created unless the **data** field changes.

Input filters follow a similar pattern. When a Gateway is connected to a Use Case, it generates a specific type of Input. This allows the Gateway to send `MyInput` instances, which are then processed by the input filter to update the Entity based on the new data.

So, if a `MyInput` instance is received, it triggers an update in the Entity's data field, leading to the creation of a new `MyUIOutput`.

**How to Update Entities in Use Cases**

You can modify Entities inside the Use Case whenever necessary:

```dart
  // Method inside the Use Case

  void updateAmount(double newAmount){
    if (entity.isAmountValid(newAmount)) {
      entity = entity.copyWith(amount: newAmount);
    } else {
      entity = entity.copyWith(error: Errors.invalidAmount);
    }
  }
```

The entity can be accessed from anywhere within a UseCase. Whenever you need to update even just one field of the entity, it's essential to replace the entire instance. If you don't do this, the Use Case won't produce any Output. This is because it functions similarly to a ValueNotifier. This is why using generator methods such as `copyWith` is so helpful!

**How Outputs Connect Use Cases with Presenters and Gateways**

Use Cases are designed without specific knowledge of external layers. Their role is to create Outputs, which can be listened to by anything. This means you should avoid making assumptions about how the data in Outputs will be used.

For instance, an Output might contain data destined for a database, for display on a screen, or to be sent to a service. It's the job of the external layers to decide the fate and application of this data.

Regarding the generation of Outputs, there are two main methods. We've already discussed output filters, which produce Outputs when there's a change in the entity.

The second method involves creating outputs on demand. This is used when the Use Case needs to wait for a response or some action from the external layers, and looks like this:

```dart
  void fetchUserData(){
    await request(
      FetchUserDataGatewayOutput(),
      onSuccess: (UserDataInput input) {
        return entity.copyWith(name: input.name);
      },
      onFailure: (_) {
        return entity.copyWith(error: Error.dataFetchError);
      },
    );
  }
```

The request method generates a Future that publishes a **FetchUserDataGatewayOutput** instance. If this output type isn't being listened to, an error is thrown. During development, you can use dummy Gateways while developing the Use Case behavior before writing external code.

The request method includes two callbacks: one for success and another for failures.

<aside class="positive">
Failures are akin to Flutter Errors, but with a key difference. Failures in Clean Framework are a structured way to handle issues arising within its components. It's the developers' job to create custom failure instances to set up analytics calls or log issues.
</aside>

<aside class="negative">
A word of caution: we generally advise against using try/catch blocks and exceptions within Clean Framework components. Instead, we recommend adhering to the aforementioned error handling methods while striving for null-safe code.
</aside>

Now, notice the onSuccess callback receives an Input. This is key because UseCase communicates with external layers exclusively through Inputs and Outputs. Any external data entering the class must come in as an Input.

If you've already read our guide on the UI layer, hopefully you have a clearer understanding of how the Presenter interacts with the Use Case at this point, especially if you've planned which Outputs to use in the output filter and Presenter.

Stay tuned for the next section of the Codelab, where we'll dive into Gateway connections.

**How Inputs Connect Use Cases with Presenters and Gateways**

For sending Inputs to Use Cases, both Gateways and Presenters can use this method:

```dart
  useCase.setInput<MyInput>(MyInput('foo'));
```

Gateways handle this process internally, but Presenters have the flexibility to use this method whenever they choose, instead of directly invoking a method on the UseCase.

<aside class ="positive">
Here's a tip: Using Inputs is generally more advantageous than calling methods directly. This approach lets you interact with the Use Case without needing to understand its inner workings, as we saw in the previous section. However, if your feature is straightforward, you might prefer direct method calls to simplify your code.
</aside>

### Writing Use Cases

Now we'll start actually writing the UseCase.

Start by defining your `HomeEntity`:

#### in lib/features/home/domain/home_entity.dart
```dart
import 'package:clean_framework/clean_framework.dart';

enum HomeStatus { initial, loading, loaded, failed }

class HomeEntity extends Entity {
  HomeEntity({
    this.pokemons = const [],
    this.pokemonNameQuery = '',
    this.status = HomeStatus.initial,
    this.isRefresh = false,
  });

  final List<PokemonData> pokemons;
  final String pokemonNameQuery;
  final HomeStatus status;
  final bool isRefresh;

  @override
  List<Object?> get props {
    return [pokemons, pokemonNameQuery, status, isRefresh];
  }

  @override
  HomeEntity copyWith({
    List<PokemonData>? pokemons,
    String? pokemonNameQuery,
    HomeStatus? status,
    bool? isRefresh,
  }) {
    return HomeEntity(
      pokemons: pokemons ?? this.pokemons,
      pokemonNameQuery: pokemonNameQuery ?? this.pokemonNameQuery,
      status: status ?? this.status,
      isRefresh: isRefresh ?? this.isRefresh,
    );
  }
}

class PokemonData extends Entity {
  PokemonData({
    required this.name,
    required this.imageUrl,
  });

  final String name;
  final String imageUrl;

  @override
  List<Object?> get props => [name, imageUrl];
}
```

Then, we'll create the `HomeUseCase`. Create a new file called `home_use_case.dart` inside the `domain` directory:

#### in lib/features/home/domain/home_use_case.dart
```dart
import 'package:clean_framework/clean_framework.dart';

import 'home_entity.dart';

class HomeUseCase extends UseCase<HomeEntity> {
  HomeUseCase() : super(entity: HomeEntity());

  Future<void> fetchPokemons({bool isRefresh = false}) async {
    if (!isRefresh) {
      entity = entity.copyWith(status: HomeStatus.loading);
    }

    // TODO: Make a request to fetch the pokemons

    if (isRefresh) {
      entity = entity.copyWith(isRefresh: false, status: HomeStatus.loaded);
    }
  }
}
```

Once you've set up the Use Case, the next step is to create a UI Output, which the Presenter will use to show data on the screen. For this, you'll need to create a file named `home_ui_output.dart` in the `domain` directory.

#### in lib/features/home/domain/home_ui_output.dart
```dart
import 'package:clean_framework/clean_framework.dart';

import 'home_entity.dart';

class HomeUIOutput extends Output {
  HomeUIOutput({
    required this.pokemons,
    required this.status,
    required this.isRefresh,
  });

  final List<PokemonData> pokemons;
  final HomeStatus status;
  final bool isRefresh;

  @override
  List<Object?> get props => [pokemons, status, isRefresh];
}
```

Now we need to create an output transformer so that the raw data in Use Case (i.e. the Entity)
can be transformed into a `UIOutput`.
Create the following class in the Use Case file:

#### in lib/features/home/domain/home_use_case.dart
```dart
class HomeUIOutputTransformer extends OutputTransformer<HomeEntity, HomeUIOutput> {
  @override
  HomeUIOutput transform(HomeEntity entity) {
    final filteredPokemons = entity.pokemons.where(
      (pokemon) {
        final pokeName = pokemon.name.toLowerCase();
        return pokeName.contains(entity.pokemonNameQuery.toLowerCase());
      },
    );

    return HomeUIOutput(
      pokemons: filteredPokemons.toList(growable: false),
      status: entity.status,
      isRefresh: entity.isRefresh,
    );
  }
}
```

To handle search input from the UI for filtering the pokemons, we also need to set up an input and input transformer. So, go ahead and add these classes to the UseCase file as well:

#### in lib/features/home/domain/home_use_case.dart
```dart
class PokemonSearchInput extends Input {
  PokemonSearchInput({required this.name});

  final String name;
}

class PokemonSearchInputTransformer extends InputTransformer<HomeEntity, PokemonSearchInput> {
  @override
  HomeEntity transform(HomeEntity entity, PokemonSearchInput input) {
    return entity.copyWith(pokemonNameQuery: input.name);
  }
}
```

Finally, integrate these transformers into your Use Case:

```dart
class HomeUseCase extends UseCase<HomeEntity> {
  HomeUseCase()
      : super(
          entity: HomeEntity(),
          transformers: [
            HomeUIOutputTransformer(),
            PokemonSearchInputTransformer(),
          ],
        );

  ...
}
```

Awesome! Our Pokemon app is getting closer to actually containing some business logic. In the next section, we'll start working on external interfaces and handling requests to interact with external services (e.g. a REST api.)
