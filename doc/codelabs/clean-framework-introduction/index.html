
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Introduction to Clean Framework</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="clean-framework-introduction"
                  title="Introduction to Clean Framework"
                  environment="web"
                  feedback-link="https://github.com/MattHamburger/clean_framework/issues">
    
      <google-codelab-step label="Overview" duration="10">
        <p>Clean Framework is a toolkit of classes and implementations that help any developer create a layered architecture on any app, following the principles of Clean Architecture from Uncle Bob (Robert Martin).</p>
<h2 is-upgraded>The Layers</h2>
<p>To understand the components, first we have to talk about the layers, which are just a way to group your code to avoid interdependencies and to separate concerns.</p>
<p>The following diagram explains how the Clean Architecture proposes the implementation of the layers.</p>
<p class="image-container"><img alt="Clean Architecture Layers" src="img/7132fc7d4eb27414.png"></p>
<p>The idea of layering the architecture to separate the domain logic from the implementation details is not recent, and some other approaches have also been proposed (like the Hexagonal Architecture). Bob Martin took good ideas from the existing proposals, so some of the terms may seem familiar.</p>
<h2 is-upgraded>Entities Layer</h2>
<p>The core of your app should exist within this layer. Here we have Entity instances that hold the state of all your features. These entities are immutable and should be free of any external code, they should not care about databases, UI, or services. If you are familiar with Domain Driven Design, this is considered your Domain data.</p>
<h2 is-upgraded>Use Cases Layer</h2>
<p>The Use Case is an object that handles the data in the Entities and redirects the flows of data. Use Cases will hold most of the business logic of your features.</p>
<p>Use Cases handle two classes, Input and Output, which move data inside or outside respectively, they are very similar to DDD Events. The next layer can only use these components to send and receive data from the Entities. Since they are simple PODOs (Plain Old Dart Objects), they are completely agnostic from the implementation of the outside layer, and this means the Use Case will usually interact with any type of object without worrying about the details.</p>
<p>To interact with the Outputs and Inputs, Use Cases use requests and filters, and these interactions can be synchronous or subscriptions.</p>
<h2 is-upgraded>Adapters Layer</h2>
<p>The goal of this layer is to translate the Inputs and Outputs from the Use Case into more specific messages for specific destinations. These components have a similar function than the BDD Adapter. We have to main components, the Presenter and the Gateway</p>
<h3 is-upgraded>Presenter</h3>
<p>It&#39;s job is to translate Outputs into ViewModels, which are contain data and behavior (in the form of callbacks). This class will hold most of your UI logic that is not business related, like navigation.</p>
<p>Presenters will interact with providers of Use Cases to subscribe to a specific Output, so when that output gets updated, we can schedule a refresh on the UI side. Once the Presenter receives the updated Output, it will create a new View Model to be processed by the UI.</p>
<h3 is-upgraded>Gateway</h3>
<p>When you need external data from sources like REST servers, databases, hardware, cache, etc. Use Cases will send requests with an specific Output. This message will be listened by a Gateway, which translates the Output data into a request that can be processed by the next layer.</p>
<p>There are two types of Gateway, depending on how you need the response to be delivered. The base Gateway class handles requests and waits for a response on the same interaction, blocking the execution until a response or an error is received.</p>
<p>The other type is the WatcherGateway, which will create a subscription. Once the result is received and sent back to the UseCase, it will keep listening for subsequent responses, which are sent to the Use Case through the Input listener.</p>
<h2 is-upgraded>External Interfaces Layer</h2>
<p>This is where code from libraries and dependencies interacts with your features. Waits for Requests to happen and then process them depending on its type. Clean Framework include some ready-to-use default implementations to work with Firebase, GraphQL and REST services.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Setup" duration="5">
        <p>To start using the Clean Framework components, you need to add the library on the pubspec.yaml of the project. Use the latest version available.</p>
<pre><code>dependencies:
    clean_framework: ^1.1.0
</code></pre>
<h2 is-upgraded>Project Structure</h2>
<p>We suggest you organize your app into Features, with the assumption that features don&#39;t depend on each other. The goal should be to be able to delete a feature completely and don&#39;t break any code.</p>
<p>Each feature could be organized in this way:</p>
<pre><code>lib
    features
        my_new_feature
            domain
                my_new_feature_usecase.dart
                my_new_feature_entity.dart
                my_new_feature_outputs.dart
                my_new_feature_inputs.
            presentation
                my_new_feature_presenter.dart
                my_new_feature_view_model.dart
            external_interfaces
                my_new_feature_gateway.dart
</code></pre>
<p>Notice that the name of the feature is a prefix for all the files inside. We prefer this naming convention so they are easier to idenfiy on searches, but you are free to follow any convention that suits your need.</p>
<p>The folder structure is also a suggestion, you can add multiple layers if the feature begins to grow and have multiple screens and interactions.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
