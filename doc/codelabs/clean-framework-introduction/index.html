
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Introduction to Clean Framework</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="clean-framework-introduction"
                  title="Introduction to Clean Framework"
                  environment="web"
                  feedback-link="https://github.com/MattHamburger/clean_framework/issues">
    
      <google-codelab-step label="Overview" duration="10">
        <p>Clean Framework is a toolkit of classes and implementations that help any developer create a layered architecture on any app, following the principles of Clean Architecture from Uncle Bob (Robert Martin).</p>
<h2 is-upgraded>The Layers</h2>
<p>To understand the components, first we have to talk about the layers, which are just a way to group your code to avoid interdependencies and to separate concerns.</p>
<p>The following diagram explains how the Clean Architecture proposes the implementation of the layers.</p>
<p class="image-container"><img alt="Clean Architecture Layers" src="img/7132fc7d4eb27414.png"></p>
<p>The idea of layering the architecture to separate the domain logic from the implementation details is not recent, and some other approaches have also been proposed (like the Hexagonal Architecture). Bob Martin took good ideas from the existing proposals, so some of the terms may seem familiar.</p>
<h2 is-upgraded>Entities Layer</h2>
<p>The core of your app should exist within this layer. Here we have Entity instances that hold the state of all your features. These entities are immutable and should be free of any external code, they should not care about databases, UI, or services. If you are familiar with Domain Driven Design, this is considered your Domain data.</p>
<h2 is-upgraded>Use Cases Layer</h2>
<p>The Use Case is an object that handles the data in the Entities and redirects the flows of data. Use Cases will hold most of the business logic of your features.</p>
<p>Use Cases handle two classes, Input and Output, which move data inside or outside respectively, they are very similar to DDD Events. The next layer can only use these components to send and receive data from the Entities. Since they are simple PODOs (Plain Old Dart Objects), they are completely agnostic from the implementation of the outside layer, and this means the Use Case will usually interact with any type of object without worrying about the details.</p>
<p>To interact with the Outputs and Inputs, Use Cases use requests and filters, and these interactions can be synchronous or subscriptions.</p>
<h2 is-upgraded>Adapters Layer</h2>
<p>The goal of this layer is to translate the Inputs and Outputs from the Use Case into more specific messages for specific destinations. These components have a similar function than the BDD Adapter. We have to main components, the Presenter and the Gateway</p>
<h3 is-upgraded>Presenter</h3>
<p>It&#39;s job is to translate Outputs into ViewModels, which are contain data and behavior (in the form of callbacks). This class will hold most of your UI logic that is not business related, like navigation.</p>
<p>Presenters will interact with providers of Use Cases to subscribe to a specific Output, so when that output gets updated, we can schedule a refresh on the UI side. Once the Presenter receives the updated Output, it will create a new View Model to be processed by the UI.</p>
<h3 is-upgraded>Gateway</h3>
<p>When you need external data from sources like REST servers, databases, hardware, cache, etc. Use Cases will send requests with an specific Output. This message will be listened by a Gateway, which translates the Output data into a request that can be processed by the next layer.</p>
<p>There are two types of Gateway, depending on how you need the response to be delivered. The base Gateway class handles requests and waits for a response on the same interaction, blocking the execution until a response or an error is received.</p>
<p>The other type is the WatcherGateway, which will create a subscription. Once the result is received and sent back to the UseCase, it will keep listening for subsequent responses, which are sent to the Use Case through the Input listener.</p>
<h2 is-upgraded>External Interfaces Layer</h2>
<p>This is where code from libraries and dependencies interacts with your features. Waits for Requests to happen and then process them depending on its type. Clean Framework include some ready-to-use default implementations to work with Firebase, GraphQL and REST services.</p>
<p>The UI layer is considered a type of External Interface layer since it also relies on messages to an adapter (the Presenter) to send and receive state changes from the entities.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Setup" duration="5">
        <p>To start using the Clean Framework components, you need to add the library on the pubspec.yaml of the project. Use the latest version available.</p>
<pre><code language="language-yaml" class="language-yaml">dependencies:
    clean_framework: ^1.1.0
</code></pre>
<h2 is-upgraded>Project Structure</h2>
<p>We suggest you organize your app into Features, with the assumption that features don&#39;t depend on each other. The goal should be to be able to delete a feature completely and don&#39;t break any code.</p>
<p>Each feature could be organized in this way:</p>
<pre><code>lib
    providers_loader.dart
    features
        my_new_feature
            domain
                my_new_feature_usecase.dart
                my_new_feature_entity.dart
                my_new_feature_outputs.dart
                my_new_feature_inputs.
            presentation
                my_new_feature_presenter.dart
                my_new_feature_view_model.dart
                my_new_feature_ui.dart
            external_interfaces
                my_new_feature_gateway.dart
</code></pre>
<p>Notice that the name of the feature is a prefix for all the files inside. We prefer this naming convention so they are easier to idenfiy on searches, but you are free to follow any convention that suits your need.</p>
<p>The folder structure is also a suggestion, you can add multiple layers if the feature begins to grow and have multiple screens and interactions.</p>
<h2 is-upgraded>The Providers</h2>
<p>Use Cases, Gateways and External Interfaces are instances of classes that are not Flutter Widgets, so they are not dependant on the Flutter Context. To have access to them, you can &#34;publish&#34; them using the Providers pattern.</p>
<p>If you notice on the files list shown above, outside the features folder we have a file where we list all the providers used on the app. For large projects this is probably not the best idea, since this file can be long and bloated, so probably splitting the providers by feature could work better.</p>
<p>This is an example on how this file can be coded:</p>
<pre><code language="language-dart" class="language-dart">final myNewFeatureUseCaseProvider =
    UseCaseProvider&lt;MyNewFeatureEntity, MyNewFeatureUseCase&gt;(
  (_) =&gt; LastLoginUseCase(),
);

final myNewFeatureGatewayProvider = GatewayProvider&lt;MyNewFeatureGateway&gt;(
  (_) =&gt; MyNewFeatureGateway(),
);

void loadProviders() {
  myNewFeatureUseCaseProvider.getUseCaseFromContext(providersContext);

  MyNewFeatureGatewayProvider.getGateway(providersContext);

  restExternalInterface.getExternalInterface(providersContext);
}
</code></pre>
<p>Clean Framework uses Riverpod for the Providers behavior, so you can understand why the providers are global instances. For anyone not familiar to how Riverpod works, this might seem innapropiate, specially comming from a strict OO formation. Justifying why this is useful and desirable, please refer to the <a href="https://riverpod.dev/docs/concepts/providers" target="_blank">Riverpod documentation</a>, since the creator already did a great job explaining this approach.</p>
<p>Providers create instances lazyly, but some of the listeners need to be connected before use cases make any request. That is why we use a global function to &#34;touch&#34; all gateway and external interfaces providers to ensure they are created when the app starts.</p>
<p>The last consideration is to remember to use the function on the main function:</p>
<pre><code language="language-dart" class="language-dart">void main() {
  loadProviders();
  runApp(MyApp());
}
</code></pre>
<aside class="special"><p> While working on this codelab, it won&#39;t be necessary to have this file from the beginning, you will see a box like this one to let you know when it will be needed. </p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="The UI Layer: UI, Presenter and View Model" duration="15">
        <p>Lets discuss in more detail the components of the UI Layer</p>
<p class="image-container"><img alt="The UI Layer" src="img/785ff89ecec6ef69.png"></p>
<p>As mentioned on the previous topic, the UI component lives on the most external layer of the architecture. It means that it is related to specific libraries that conform the frontend of the application, in our case, the Flutter widgets libraries.</p>
<p>When building an app using the Clean Framework classes, we try to separate as much as possible any code that is not related to pure UI logic and put that on the Presenter (to send and receive data from internal layers) and the Use Case (the normal location for business logic).</p>
<p>UI is a class that behaves like a Stateless Widget. It will be very rare that a Stateful Widget is needed, since the state usage for important data breaks the layer rules. Try to always think on ways the UI widgets without the need for Stateful Widgets.</p>
<p>All UI implementations require at least one View Model to fetch data from the entities. This data comes from Use Case Outputs, which Presenters receive and translate as needed.</p>
<p>The feature you code can be expresed into multiple screens presented to the user, and even include small widgets that are inserted in other screens. These are your entry points to the feature, and as such, will require for the UI to listen to the state changes of the feature&#39;s Use Case through its Outputs. In other words, Use Cases can have multiple Outputs, that can have relationships with many View Models through the Presenters.</p>
<p>View Models are immutable classes, almost pure PODO&#39;s (Plain Old Dart Objects). We try to make them as lean as possible, because its only responsibility is the passing of digested data fields into the UI object.</p>
<p>They tend to have only Strings. This is intentional since the Presenter has the responsibility of any formating and parsing done to the data.</p>
<p>Finally, the Presenters purpose is to connect and listen to Use Case Providers to interact with the Use Case instance and pass messages for user actions done on the UI (through callbacks on the View Model) and also to trigger rebuilds on the UI when the state changes causes a new Output to be generated. This will be explained in detail on the following sessions, so for now just asume the Presenters associate with only one type of Output.</p>
<p>The most important job of the Presenter is to translate an Output instance and create a new View Model everytime the Output is received.</p>
<h2 is-upgraded>Testing and Coding the UI Layer</h2>
<p>After a feature folder is created, any developer will probably try to start adding Flutter Widgets to build up the code requirements. This framework is flexible enough to allow you to start coding components that don&#39;t require to have any access or even knowledge of any possible dependency (databases, services, cache, etc), because those concerns belong to other layers.</p>
<p>The simplest way to start working on a new feature is to first decide how many UI elements will be required to complete the implementation of the feature. For the sake of simplicity we are going to considering only one widget for the single screen of the new feature.</p>
<aside class="special"><p> While working on this codelab, we will be creating the code by using TDD so we can focus on stablishing the desired outcome before explaining the code that produces it. </p>
</aside>
<h2 is-upgraded>The feature requirements</h2>
<p>We are going to code a very simple feature which can be explained in a few Gherkin scenarios:</p>
<pre><code language="language-gherkin" class="language-gherkin">Given I have navigated to the Add Machine feature
Then I will see the Add Machine screen
And the total shown will be 0.

Given I opened the Add Machine feature
When I write a number on the number field
And I press the &#34;Add&#34; button
Then the total shown will be the entered number.

Given I have entered a number on the Add Machine feature
When I write another number and press &#34;Add&#34;
Then the total shown will be the sum of both numbers.

Given I have added one or more numbers on the Add Machine feature
When I navigate away and open the feature again
Then the total shown is 0.
</code></pre>
<p>And this is the design of the page, which we have as reference, but the scope of the codelab won&#39;t be to focus on completing the code to reflect exactly the appearance, it will be up to you to finish the implementation.</p>
<p class="image-container"><img alt="Add Machine Design" src="img/c67ac4d94ed214f1.png"></p>
<aside class="warning"><p> These are not the only scenarios that should exist, since we are not covering possible error scenarios, like when the user adds no input at all, or tries to write something that is not a number. We leave the gaps of behavior out to be covered as an additional exercise for the developers. </p>
</aside>
<h2 is-upgraded>The UI component test</h2>
<p>UI components are extensions of Flutter Widgets, so this means the we have to use a Widget Tester. Our goal is to confirm that the data is retrieved correctly from the view model.</p>
<p>This is how our basic test looks like:</p>
<h3 is-upgraded>test/features/add_machine/presentation/add_machine_ui_test.dart</h3>
<pre><code language="language-dart" class="language-dart">void main() {
    uiTest(
        &#39;AddMachineUI unit test&#39;,
        context: ProvidersContext(),
        builder: () =&gt; AddMachineUI(),
        verify: (tester) async {

            expect(find.text(&#39;Add Machine&#39;), findsOneWidget);

            final sumTotalWidget = find.byKey(Key(&#39;SumTotalWidget&#39;));
            expect(sumTotalWidget, findsOneWidget);

            expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;0&#39;)), findsOneWidget);

        },
    );
}
</code></pre>
<p>After creating the initial blank project (using ‘flutter create&#39; for instance), you can add this test under the suggested path (features/add_machine/presentation).</p>
<aside class="warning"><p> Be aware that TDD rules should cause the developer to not write more code than what is needed in order to make the test pass, but recreating the actual process will be lengthy for this codelab. We are oversimplifying the process here. </p>
</aside>
<p>Now, to explain the code:</p>
<ul>
<li>Notice how we are using our own &#34;tester&#34; component, the uiTest function. This helper uses a Widget tester internally, but also helps on the setup of a MaterialApp with a proper provider context. The context allows the override of already defined providers if needed.</li>
<li>The builder creates an instance of a class that extends from the Clean Framework UI abstract class.</li>
<li>Verify is a function parameter to attach all the expects and actions done normally on widget tests.</li>
</ul>
<p>The test is confirming that the first Gherkin scenario happens correctly, but of course the test cannot pass until we have coded the actual UI class. The first piece of code we have to provide is precisely this UI implementation.</p>
<p>But in practice, we not only need that. UI is coupled to a valid ViewModel, which gets translated from a specific Output inside a Presenter. So lets create the minimal code on these classes to make the test pass:</p>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_ui.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineUI extends UI&lt;AddMachineViewModel&gt; {
  AddMachineUI({required PresenterCreator&lt;AddMachineViewModel&gt; create})
      : super(create: create);

  @override
  Widget build(BuildContext context, AddMachineViewModel viewModel) {
    return Column(children: [
      Text(&#39;Add Machine&#39;),
      Container(
        key: Key(&#39;SumTotalWidget&#39;),
        child: Text(viewModel.total),
      ),
    ]);
  }

  @override
  create(PresenterBuilder&lt;AddMachineViewModel&gt; builder) {
    throw UnimplementedError();
  }
}
</code></pre>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_view_model.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineViewModel extends ViewModel {
  final String total;

  AddMachineViewModel({required this.total});

  @override
  List&lt;Object?&gt; get props =&gt; [total];
}
</code></pre>
<p>Let&#39;s review the code so far:</p>
<ul>
<li>The UI class specifies by generics the usage of a AddMachineViewModel. This way the class can have access to any field of the model.</li>
<li>A constructor is provided to accept a creator function. This is normally not needed. The &#34;normal&#34; implementation instanciates the proper presenter on the create override. But to make the test pass we can have a presenter that doesn&#39;t use a Use Case provider, but builds a static view model instead. This is useful for unit tests that use fake presenters.</li>
<li>Since the presenter has a mocked behavior, the actual class is defined on the test file, and the create override is left as is (it will never be called on execution).</li>
</ul>
<p>Now let&#39;s look at the necessary changes to the test itself:</p>
<h3 is-upgraded>test/features/add_machine/presentation/add_machine_ui_test.dart</h3>
<pre><code language="language-dart" class="language-dart">void main() {
  uiTest(
    &#39;AddMachineUI unit test&#39;,
    context: ProvidersContext(),
    builder: () =&gt; AddMachineUI(
      create: (builder) =&gt; AddMachinePresenter(builder: builder),
    ),
    verify: (tester) async {
      expect(find.text(&#39;Add Machine&#39;), findsOneWidget);

      final sumTotalWidget = find.byKey(Key(&#39;SumTotalWidget&#39;));
      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;0&#39;)),
          findsOneWidget);
    },
  );
}

class AddMachinePresenter
    extends Presenter&lt;AddMachineViewModel, AddMachineUIOutput, UseCase&gt; {
  AddMachinePresenter({
    required PresenterBuilder&lt;AddMachineViewModel&gt; builder,
  }) : super(provider: addMachineUseCaseProvider, builder: builder);

  @override
  AddMachineViewModel createViewModel(UseCase&lt;Entity&gt; useCase, output) =&gt;
      AddMachineViewModel(total: output.total.toString());

  AddMachineUIOutput subscribe(_) =&gt; AddMachineUIOutput(total: 0);
}

class AddMachineUIOutput extends Output {
  final int total;

  AddMachineUIOutput({required this.total});

  @override
  List&lt;Object?&gt; get props =&gt; [total];
}

final addMachineUseCaseProvider = UseCaseProvider((_) =&gt; UseCaseFake());

</code></pre>
<p>The Presenter, Output and UseCaseProvider are using as much fake data as possible to control the outcome of the test.</p>
<aside class="special"><p> We use to write any mocks and fakes in the test file that uses them, and try to not share them, since scenarios change over time and trying to refactor all the helpers and derivates can be a complex and time-consuming task. Projects benefit more from fast unit tests that can be changed easily over time. If this doesn&#39;t fit your company policy, feel free to adapt the implementation to your needs. </p>
</aside>
<h2 is-upgraded>A complete Presenter</h2>
<p>Now lets evolve our current code so we can test the second scenario. This is the test for it:</p>
<pre><code language="language-dart" class="language-dart">/// Given I opened the Add Machine feature
  /// When I write a number on the number field
  /// And I press the &#34;Add&#34; button
  /// Then the total shown will be the entered number.
  uiTest(
    &#39;AddMachineUI unit test - Scenario 2&#39;,
    context: ProvidersContext(),
    builder: () =&gt; AddMachineUI(
      create: (builder) =&gt; AddMachinePresenter(builder: builder),
    ),
    verify: (tester) async {
      final numberField = find.byKey(Key(&#39;NumberField&#39;));
      expect(numberField, findsOneWidget);

      await tester.enterText(numberField, &#39;15&#39;);

      final addButton = find.byKey(Key(&#39;AddButton&#39;));
      expect(addButton, findsOneWidget);

      await tester.tap(addButton);

      final sumTotalWidget = find.byKey(Key(&#39;SumTotalWidget&#39;));
      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;15&#39;)),
          findsOneWidget);
    },
  );
</code></pre>
<aside class="special"><p> There are opportunities to refactor the two tests, since we are repeating usages of finders, but it would be hard to understand the code on the codelab, we will have to constantly be looking at all the tests to understand the code. We leave that effort to you. </p>
</aside>
<p>To make this test work, we will need to first move the Presenter code into its corresponding place inside the production features code, complete the implementation, and make the test use a fake Use Case that publishes a single static Output.</p>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_presenter.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachinePresenter
    extends Presenter&lt;AddMachineViewModel, AddMachineUIOutput, UseCase&gt; {
  AddMachinePresenter({
    required UseCaseProvider provider,
    required PresenterBuilder&lt;AddMachineViewModel&gt; builder,
  }) : super(provider: provider, builder: builder);

  @override
  AddMachineViewModel createViewModel(useCase, output) =&gt; AddMachineViewModel(
      total: output.total.toString(),
      onAddNumber: (number) =&gt; _onAddNumber(useCase, number));

  void _onAddNumber(useCase, String number) {
    useCase.setInput&lt;AddMachineAddNumberInput&gt;(
        AddMachineAddNumberInput(int.parse(number)));
  }
}
</code></pre>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_view_model.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineViewModel extends ViewModel {
  final String total;
  final ValueChanged&lt;String&gt; onAddNumber;

  AddMachineViewModel({required this.total, required this.onAddNumber});

  @override
  List&lt;Object?&gt; get props =&gt; [total];
}
</code></pre>
<h3 is-upgraded>lib/features/add_machine/domain/add_machine_ui_output.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineUIOutput extends Output {
  final int total;

  AddMachineUIOutput({required this.total});

  @override
  List&lt;Object?&gt; get props =&gt; [total];
}
</code></pre>
<h3 is-upgraded>lib/features/add_machine/domain/add_machine_add_number_input.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineAddNumberInput extends Input {
  final int number;

  AddMachineAddNumberInput(this.number);
}

class AddMachineViewModel extends ViewModel {
  final String total;
  final ValueChanged&lt;String&gt; onAddNumber;

  AddMachineViewModel({required this.total, required this.onAddNumber});

  @override
  List&lt;Object?&gt; get props =&gt; [total];
}
</code></pre>
<p>About the code so far:</p>
<ul>
<li>The Presenter got rid of the &#34;subscribe&#34; override since we will depend now entirely on an AddMachineUIOutput object from a provided use case.</li>
<li>When sending messages to the use case, we can either do it through a custom method or by using an Input, as we are doing here. Using the input helps us to not have to declare a custom Use Case, to make the test pass with as little code as possible.</li>
<li>The View Model has a new attribute, the callback that we will use to link the user action on the UI with an Input that is sent to the Use Case. <strong><em>Notice how callbacks are not considered part of the fieds used for equality comparisons.</em></strong></li>
<li>Both input and output classes now are inside the proper folder. UI components can import from domain files, and at this point, only the Presenter and test mocks create instances of them.</li>
</ul>
<p>We have to make fixes on the UI to add the new widgets:</p>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_ui.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineUI extends UI&lt;AddMachineViewModel&gt; {
  final UseCaseProvider provider;

  AddMachineUI({required this.provider});

  @override
  Widget build(BuildContext context, AddMachineViewModel viewModel) {
    final fieldController = TextEditingController();
    return Scaffold(
      body: Column(children: [
        Text(&#39;Add Machine&#39;),
        Container(
          key: Key(&#39;SumTotalWidget&#39;),
          child: Text(viewModel.total),
        ),
        TextFormField(
          key: Key(&#39;NumberField&#39;),
          controller: fieldController,
          decoration: const InputDecoration(
              border: UnderlineInputBorder(), labelText: &#39;Write a number&#39;),
        ),
        ElevatedButton(
          key: Key(&#39;AddButton&#39;),
          onPressed: () =&gt; viewModel.onAddNumber(fieldController.value.text),
          child: Text(&#39;Add&#39;),
        ),
      ]),
    );
  }

  @override
  create(PresenterBuilder&lt;AddMachineViewModel&gt; builder) =&gt;
      AddMachinePresenter(provider: provider, builder: builder);
}
</code></pre>
<ul>
<li>Notice that now the View Model has a callback field, which the UI calls to send the current number text to the Presenter. This is the goal of the code separation, we delegate the parsing and validation of the field value to the Presenter, which in turn can rely on the Use Case for complex validations.</li>
<li>We are intentionally creating a TextEditingController inside a build method. This is not what Flutter developers normally do, since any rebuild will override the current value, but for this simple feature this is enough. If this becomes an issue, then we suggest creating a wrapper widget around your field, with a state that handles the controller, just remember to avoid using the state for anything else.</li>
</ul>
<p>Now that we have a full presenter implementation, the test can stop relying on the test presenter we coded previously, and change the mocks, now we need to mock the Use Case, as follows:</p>
<h3 is-upgraded>test/features/add_machine/presentation/add_machine_ui_test.dart</h3>
<pre><code language="language-dart" class="language-dart">void main() {
  uiTest(
    &#39;AddMachineUI unit test - Scenario 2&#39;,
    context: ProvidersContext(),
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    verify: (tester) async {
      final numberField = find.byKey(Key(&#39;NumberField&#39;));
      expect(numberField, findsOneWidget);

      await tester.enterText(numberField, &#39;15&#39;);

      final addButton = find.byKey(Key(&#39;AddButton&#39;));
      expect(addButton, findsOneWidget);

      await tester.tap(addButton);
      await tester.pumpAndSettle();

      final sumTotalWidget = find.byKey(Key(&#39;SumTotalWidget&#39;));
      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;15&#39;)),
          findsOneWidget);
    },
  );
}

final addMachineUseCaseProvider = UseCaseProvider((_) =&gt; StaticUseCase([
      AddMachineUIOutput(total: 0),
      AddMachineUIOutput(total: 15),
    ]));
    
class StaticUseCase extends UseCase&lt;EmptyEntity&gt; {
  static int _index = 0;
  final List&lt;Output&gt; outputs;

  StaticUseCase(this.outputs) : super(entity: EmptyEntity());

  @override
  void setInput&lt;I extends Input&gt;(I input) {
    _index++;
    entity = EmptyEntity();
  }

  @override
  O getOutput&lt;O extends Output&gt;() {
    return outputs[_index] as O;
  }
}

class EmptyEntity extends Entity {
  @override
  List&lt;Object?&gt; get props =&gt; [];
}

</code></pre>
<aside class="special"><p> Remember that as part of the TDD methodology, you will be constantly refactoring and updating the tests the more production code you complete, at this point you can see that the UseCaseFake is basically a minimal functioning Use Case. This is done intentionally to exemplify how fakes can be used to avoid writing production code before it&#39;s actually needed. For a normal real-case project, this is probably a step you can skip. </p>
</aside>
<p>Hopefuly by now you can appreciate the capacity of the Clean Framework components to help developers work with the UI layer without the need to first finish the Domain Layer code. You can even work in paralel with another developer that is doing it, while also having a high coverage on your code.</p>
<p>It has to be noted that this is very helpful to create MVP builds and have a working prototype that can be reviewed by stakeholders and QA teams, saving the development team a lot of headaches, since the feedback can be received sooner.</p>


      </google-codelab-step>
    
      <google-codelab-step label="The Domain Layer: Entity, Use Case and the interactions with Outputs and Inputs" duration="10">
        <p>Congratulations, at this point we are ready to start exploring the Domain Layer, the heart of anything important for the project.</p>
<p class="image-container"><img alt="Domain Layer Components" src="img/114426cedf96e3a2.png"></p>
<h2 is-upgraded>Entity</h2>
<p>Let&#39;s start by understanding the Entities. If you are familiar with Domain Driven Design (DDD), you already know how important are the Domain components to an app. When the design is robust, there is a zero chance that the state of the app failes due to validation or null errors. Domain models have strict rules so it is very hard to create instances with inconsistent states.</p>
<p>The sum of all your Entities is the state of the whole feature. This state will be kept alive as long as its Use Case exists. Since we create it when the app is executed (using a provider), this reference is alive until the app is removed from memory.</p>
<p>So it is important to understand that this state needs initial values and rules governing how those values chage. When writing an Entity, try to follow these rules:</p>
<ol type="1">
<li>Entities don&#39;t depend on other files or libraries except for the clean framework import. This is the most central layer, so it should not need anything, not even from other features. Shared enums are even problematic, since feature requirements could change, forcing you to refactor the affected features.</li>
<li>Attributes should be final and have initial values on construction. Some of them could be required values, inserted at the time the UseCase is created as well (explained in the following section).</li>
<li>Use proper data types instead of relaying on parsers. For example, use DateTime instead of a String for a date attribute. You can parse the date in Presenters and Gateways.</li>
<li>It is OK to create a hierarchy of entities, but keep a single ancestor that the Use Case can create easily. Composition is much better than inheritance. Functional constructs like Either and Unions are useful here as well.</li>
<li>Add generators like <strong>copyWith</strong> or <strong>merge</strong> to create instances based on current values. This simplifies the Use Case code.</li>
</ol>
<p>It is OK to add methods to validate the consistency of the data. For example:</p>
<pre><code language="language-dart" class="language-dart">class AccountEntity extends Entity{
  final bool isRegistered;
  final UserNameEntity userName;

  AccountEntity({required this.isRegistered, this.userName});
}

class UserNameEntity extends Entity{
  final String firstName;
  final String lastName;

  UserNameEntity({required this.firstName, this.lastName}) : assert(firstName.isNotEmpty() &amp;&amp; lastName.isNotEmpty);

  String get fullName =&gt; firstName + &#39; &#39; + lastName;
}
</code></pre>
<p>See how it is virtually impossible to create an inconsistent user name with null or empty first and last name, and we have a dynamic getter that builds the full name.</p>
<p>This has two main advantages:</p>
<ol type="1">
<li>Developers will not write wrong code around this entity fields, since they have syntax errors or exceptions that are easy to catch while writing tests and coding.</li>
<li>The custom logic to compose fields is delegated to the Entity and is not floating around next other business logic from the Use Case, making the Use Case code easier to read.</li>
</ol>
<p>Try to delegate similar helper methods to the Entity, where they only rely on the data, such as form validations, math calculations, derivatives, etc.</p>
<aside class="warning"><p> Be careful to not add logic that doesn&#39;t belong to the Entities, or you will be bleeding behavior that should belong to the Use Case. Remember the layers rules, and think if your method is still valuable if the rest of the layers change or are even removed. </p>
</aside>
<h2 is-upgraded>Use Case</h2>
<p>Use Cases live outside the Entities, on its own layer. Use Cases will create and manipulate Entities internally, while transfering data from Inputs and into Outputs. Lets look at one simple example to understand the class:</p>
<pre><code language="language-dart" class="language-dart">class MyUseCase extends UseCase&lt;MyEntity&gt; {
  MyUseCase()
      : super(entity: MyEntity(), outputFilters: {
          MyUIOutput: (MyEntity e) =&gt; MyUIOutput(data: e.data),
        }, inputFilters: {
          MyInput: (MyInput i, MyEntity e) =&gt; e.copyWith(data: i.data),
        });
}
</code></pre>
<p>A typical Use Case will need to create an Entity. The output filters attribute lets you set up a list of possible &#34;channels&#34; that Presenters can use to subscribe to.</p>
<p>Here, MyUseCase has only one output, so the Presenter only needs to listen to MyUIOutput instances, which will be generated when the Presenter is created and any time the Entity <strong>data</strong> field changes.</p>
<p>Notice that the filter is a Map of the type of the Output and a function that receives the current Entity instance. It is intended to do it this way so its easier to isolate the code and help the developer think on simple terms and avoid having complex method calls.</p>
<p>Outputs are meant to only hold a subset of the data available in the Entity, and the way the Presenter and UseCase communication works internally, a new Output is <strong>only</strong> generated if the fields used for its construction chage. In this example, the Use Case can alter the Entity, but if the <strong>data</strong> field remains the same, no new Output is created.</p>
<p>Input filters work in a similar way. If a Gateway is attached to a Use Case, it produces a specific type of Input. This class allows a Gateway to send a MyInput instance, which will be used by the input filter anonymous method to create a new version of the Entity based on the data received.</p>
<p>So this means that a MyInput instance is received, it will trigger a Entity change on the data field, and thus generate a new MyUIOuput.</p>
<p>Entities can be changed at any time in other methods inside the Use Case, as in here:</p>
<pre><code language="language-dart" class="language-dart">  // Method inside the Use Case

  void updateAmount(double newAmount){
    if (entity.isAmountValid(newAmount))
      entity = entity.merge(amount: newAmount);
    else
      entity = entity.merge(error: Errors.invalidAmount);
  }
</code></pre>
<p>The <strong>entity</strong> attribute is available in any UseCase. Each time we need to change at least one field, we need to replace the whole instance. If this is not done, the Use Case will not generate any Output, since it behaves like a ValueNotifier</p>
<h2 is-upgraded>Outputs for Presenters and Gateways</h2>
<p>Use Cases have no knowledge of the world of the ouside layers. They only create Outputs that can be listened by anything. That is why you have to keep the implementation independant from any assumption about the data.</p>
<p>For example, an Output can contain data that will be stored in a database, visualized on a screen, or sent to a service. Only the external layers will determine where the data goes and how it is used.</p>
<p>There are two ways the Use Case sends out Outputs. We already reviewed the output filters, which generate them after the entity changes.</p>
<p>But to create outputs on demand and wait for some kind of response from the outside layers, we use the following:</p>
<pre><code language="language-dart" class="language-dart">  void fetchUserData(){
    await request(FetchUserDataOutput(), onSuccess: (UserDataInput input) {
      return entity.merge(
          name: input.name);
    }, onFailure: (_) {
      return entity.merge(error: Error.dataFetchError);
    });
  }
</code></pre>
<p>The request method creates a Future where the instance of <strong>FetchUserDataOuput</strong> is published. If no one is listening to this specific type of output, an error is thrown. During development you might attach dummy Gateways to help you complete the Use Case behavior without the need to write any outside code.</p>
<p>The request has two callbacks, for success and failures respectively.</p>
<aside class="special"><p> Failures are similar to Flutter Errors, the difference is that Failures are a controlled way to catch problems caused in the Clean Framework components. Its up to the developers to create custom instances of the failures to set up analytics calls or log the issues. </p>
</aside>
<aside class="warning"><p> We try to discourage the usage of try/catch blocks and exceptions inside Clean Framework components. Developers should try to follow our intended ways to handle errors while writting code as null safe as possible. </p>
</aside>
<p>Notice how the onSuccess callback is receiving an Input. Remember UseCase communicates with the external layer only with Inputs and Outputs. When outside data needs to come inside the class, it has to be through an Input.</p>
<p>We have already done the Presenter implementation, and now you have a bit more understanding on how it connects to the Use Case. As long as you plan correctly which Outputs will be used on the output filter and by the Presenter, then everything will be handled internally.</p>
<p>Gateways connections will be explained on the next section of the Codelab.</p>
<h2 is-upgraded>Inputs for Presenters and Gateways</h2>
<p>When Gateways and Presenters need to send Inputs to the Use Case, both can use this method:</p>
<pre><code language="language-dart" class="language-dart">  useCase.setInput&lt;MyInput&gt;(MyInput(&#39;foo&#39;));
</code></pre>
<p>Gateways do this for you internally, but Presenters are free to use this method at anytime instead of calling a specific method on the UseCase.</p>
<aside class="special"><p> Inputs are better than calling methods since you don&#39;t require any knowledge on the Use Case implemetation, as we demonstrated on the previous section. If the feature is very simple, you can opt to use methods directly to have less code overall. </p>
</aside>
<h2 is-upgraded>Testing and Coding Use Cases</h2>
<p>Now we are ready to continue the feature implementation we started on the previous section. Let&#39;s start with the test for the third Gherkin scenario:</p>
<h3 is-upgraded>test/features/add_machine/presentation/add_machine_ui_test.dart</h3>
<pre><code language="language-dart" class="language-dart">  /// Given I have entered a number on the Add Machine feature
  /// When I write another number and press &#34;Add&#34;
  /// Then the total shown will be the sum of both numbers.
  uiTest(
    &#39;AddMachineUI unit test - Scenario 3&#39;,
    context: ProvidersContext(),
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    verify: (tester) async {
      final numberField = find.byKey(Key(&#39;NumberField&#39;));
      expect(numberField, findsOneWidget);

      await tester.enterText(numberField, &#39;15&#39;);

      final addButton = find.byKey(Key(&#39;AddButton&#39;));
      expect(addButton, findsOneWidget);

      await tester.tap(addButton);
      await tester.pumpAndSettle();

      final sumTotalWidget = find.byKey(Key(&#39;SumTotalWidget&#39;));
      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;15&#39;)),
          findsOneWidget);

      await tester.enterText(numberField, &#39;7&#39;);
      await tester.tap(addButton);
      await tester.pumpAndSettle();

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;22&#39;)),
          findsOneWidget);
    },
  );

  // Replace the provider with these lines:
  final addMachineUseCaseProvider = UseCaseProvider((_) =&gt; StaticUseCase([
      AddMachineUIOutput(total: 0),
      AddMachineUIOutput(total: 15),
      AddMachineUIOutput(total: 22),
    ]));
</code></pre>
<p>This is basically a copy/paste of the previous test, the only needed change is the use case fake now returning an additional output.</p>
<p>Once we have this test coded and passing, its time for some major refactoring on all three tests, since now we want to use a production-worthy use case. Let&#39;s add the new Entity and Use Case into their corresponding place inside the domain folder:</p>
<h3 is-upgraded>lib/features/add_machine/domain/add_machine_add_entity.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineEntity extends Entity {
  final int total;

  AddMachineEntity(this.total);

  @override
  List&lt;Object?&gt; get props =&gt; [total];
}
</code></pre>
<h3 is-upgraded>lib/features/add_machine/domain/add_machine_use_case.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineUseCase extends UseCase&lt;AddMachineEntity&gt; {
  AddMachineUseCase()
      : super(entity: AddMachineEntity(0), outputFilters: {
          AddMachineUIOutput: (AddMachineEntity e) =&gt;
              AddMachineUIOutput(total: e.total),
        }, inputFilters: {
          AddMachineAddNumberInput:
              (AddMachineAddNumberInput i, AddMachineEntity e) =&gt;
                  AddMachineEntity(i.number + e.total),
        });
}
</code></pre>
<h3 is-upgraded>test/features/add_machine/presentation/add_machine_ui_test.dart</h3>
<pre><code language="language-dart" class="language-dart">// rest of code above, this is the only change:
final addMachineUseCaseProvider = UseCaseProvider((_) =&gt; AddMachineUseCase());
</code></pre>
<p>After these changes, all 3 tests pass as normal, very easy refactor, right?</p>
<p>Congratulations if you made it until this point, on the next section we will plug-in a Gateway,</p>


      </google-codelab-step>
    
      <google-codelab-step label="Adapter Layer: Gateways" duration="0">
        <p>We already learned part of this layer componets with the Presenter and View Model. The only thing left to learn here are the Gateways, which handle Outputs used as requests, and create Inputs to be processed by the Use Case.</p>
<p class="image-container"><img alt="Adapter Layer Components" src="img/2072d7c7b0cca78e.png"></p>
<p>Let&#39;s look at a simple example first:</p>
<pre><code language="language-dart" class="language-dart">class MyGateway extends Gateway&lt;MyOutput,
    MyRequest, MyResponse, MyInput&gt; {
  LastLoginDateGateway({ProvidersContext? context, UseCaseProvider? provider})
      : super(
            context: context ?? providersContext,
            provider: provider ?? lastLoginUseCaseProvider);

  @override
  MyRequest buildRequest(MyOutput output) {
    return MyRequest(data: output.data);
  }

  @override
  MyInput onSuccess(covariant FirebaseSuccessResponse response) {
    return MyInput(data: response.data);
  }

  @override
  FailureInput onFailure(FailureResponse failureResponse) {
    return FailureInput();
  }
}

final myGatewayProvider = GatewayProvider&lt;MyGateway&gt;(
  (_) =&gt; MyGateway(),
);
</code></pre>
<p>In a very similar role to a Presenter, the Gateways are translators, take Outputs and create Requests, passing the data, and when the data is received as a Response, then translate it into a valid Input.</p>
<p>This is the way we create a bridge between very specific libraries and dependencies and the agnostic Domain layer. Gateways exist on a 1 to 1 relationship for every type of Output that is lauched as part of a request from the Use Case.</p>
<p>Since they are created at the start of the execution through a Provider, keep in mind that a <em>loader</em> of providers help you ensure an instance of the Gateway exists before attempting to create requests.</p>
<p>The implementation makes the intent very clear: when the Output is launched, it triggers the <strong>onSuccess</strong> method to create a Request, which in turns gets launched to any External Interface that is listening to those types of requests.</p>
<p>When the Response is launched by the External Interface, it could come back as a succesful or failed response. On each case, the Gateway generates the proper Input, which is pushed into the Use Case immediately.</p>
<p>These Gateways create a circuit that is thread-blocking. For when you want to create a request that doesn&#39;t require an immediate response, you can use another type of Gateway:</p>
<pre><code language="language-dart" class="language-dart">class MyGateway extends WatcherGateway&lt;MyOutput,
    MyRequest, MyResponse, MyInput&gt; {
      // rest of the code is the same
    }
</code></pre>
<p>When extending the WatcherGateway, the External Interface connected to this Gateway will be able to send a stream of Responses. Each time a Response is received, the <strong>onSuccess</strong> method will be invoked, so a new Input gets created.</p>
<p>The Use Case in this case will need to setup a proper input filter to allow the Inputs to change the Entity multiple times.</p>
<p>For WatcherGateways, the <strong>onFailure</strong> method happens when the subscription could not be set for some reason. For example, for Firebase style dependencies, it could happen when attempting to create the connection for the stream of data.</p>
<h2 is-upgraded>Testing and Coding the Gateway</h2>
<p>Let&#39;s go back to the code of the Add Machine app we used on the previous section. The only scenario we have to code is the one that confirms the number is reset everytime you open the app.</p>
<p>Creating a test for that is trivial, since we can either add an integration test that does the steps, or create a setup idential to a state where the app has closed the feature.</p>
<p>But none of this will require us to write a Gateway or External Interface, so we will need to modify the requirements. Let&#39;s assume that the stakeholders found it was more helpful if we retrieved the previous calculated total each time with opened the feature.</p>
<p>This change will require that the apps &#34;remembers&#34; the last total in some way, which will easily require an External Interface. We don&#39;t have to decide right now how we are going to store the number. It is more important to finish the implementation the simplest way possible, which is to keep the number in memory inside the External Interface.</p>
<p>Right now we will only care about our Gateway, and how the Use Case will talk to it. So before we jump into the code, lets code the test that needs to pass:</p>
<h3 is-upgraded>test/features/add_machine/presentation/add_machine_ui_test.dart</h3>
<pre><code language="language-dart" class="language-dart">  /// Given I have added one or more numbers on the Add Machine feature
  /// When I navigate away and open the feature again
  /// Then the total shown is the previous total that was shown.

uiTest(
    &#39;AddMachineUI unit test - Scenario 4&#39;,
    context: context,
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    setup: () {
      final gateway = AddMachineGetTotalGateway(
          context: context, provider: addMachineUseCaseProvider);
      gateway.transport =
          (request) async =&gt; Right(AddMachineGetTotalResponse(740));

      final gatewayProvider = GatewayProvider((_) =&gt; gateway);
      gatewayProvider.getGateway(context);
    },
    verify: (tester) async {
      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;740&#39;)),
          findsOneWidget);
    },
  );

//...
final context = ProvidersContext();
final addMachineUseCaseProvider = UseCaseProvider((_) =&gt; AddMachineUseCase());

</code></pre>
<p>This time we use another type of helper, <strong>ProviderTester</strong> is a bit more flexible, since it can be used to test components that are not UI objects, while still providing a providers context.</p>
<p>Here we are assuming we will have a Home widget that loads our feature UI, and shows us the total. We have to make the app now show that number instead of a 0. This number will be created by the Gateway for now, later we will move it to the External Interface.</p>
<aside class="special"><p> When adding gateways on tests, we can directly &#34;connect&#34; the transport method so we can insert whatever response we need for the test. </p>
</aside>
<p>Now, lets jump into the Gateway code:</p>
<h3 is-upgraded>lib/features/add_machine/external_interface/add_machine_get_total_gateway.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineGetTotalGateway extends Gateway&lt;
    AddMachineGetTotalOutput,
    AddMachineGetTotalRequest,
    AddMachineGetTotalResponse,
    AddMachineGetTotalInput&gt; {
  AddMachineGetTotalGateway({
    ProvidersContext? context,
    UseCaseProvider? provider,
    UseCase? useCase,
  }) : super(context: context, provider: provider, useCase: useCase);

  @override
  buildRequest(AddMachineGetTotalOutput output) {
    return AddMachineGetTotalRequest();
  }

  @override
  FailureInput onFailure(covariant FailureResponse failureResponse) {
    throw UnimplementedError();
  }

  @override
  onSuccess(covariant AddMachineGetTotalResponse response) {
    return AddMachineGetTotalInput(response.number);
  }
}

class AddMachineGetTotalRequest extends Request {}

class AddMachineGetTotalResponse extends SuccessResponse {
  final int number;

  AddMachineGetTotalResponse(this.number);
}
</code></pre>
<p>As we learned previously, our Gateway will be associated only with a <strong>AddMachineGetTotalOutput</strong>, which will get translated into a <strong>AddMachineGetTotalRequest</strong> object. The output doesn&#39;t send any extra data, so our Request is also empty.</p>
<p>The <strong>AddMachineGetTotalResponse</strong> will hold the preserved number that we retrieve on the External Interface, so the Gateway needs to get it on a successful response and produce a valid <strong>AddMachineGetTotalInput</strong> that the Use Case can process.</p>
<p>And with this code, the only thing we need to do is make the UseCase do a request to actually retrieve the number:</p>
<h3 is-upgraded>lib/features/add_machine/domain/add_machine_use_case.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineUseCase extends UseCase&lt;AddMachineEntity&gt; {
  AddMachineUseCase()
      : super(entity: AddMachineEntity(0), outputFilters: {
          AddMachineUIOutput: (AddMachineEntity e) =&gt;
              AddMachineUIOutput(total: e.total),
        }, inputFilters: {
          AddMachineAddNumberInput:
              (AddMachineAddNumberInput i, AddMachineEntity e) =&gt;
                  AddMachineEntity(i.number + e.total),
        }) {
    onCreate();
  }

  void onCreate() {
    request(AddMachineGetTotalOutput(),
        onSuccess: (AddMachineGetTotalInput input) {
          return AddMachineEntity(input.number);
        },
        onFailure: (_) =&gt; entity);
  }
}
</code></pre>
<p>Here we are adding a way to trigger a request. This <strong>onCreate</strong> method will be used by the Presenter once the UI is built, as follows:</p>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_presenter.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachinePresenter extends Presenter&lt;AddMachineViewModel,
    AddMachineUIOutput, AddMachineUseCase&gt; {
  AddMachinePresenter({
    required UseCaseProvider provider,
    required PresenterBuilder&lt;AddMachineViewModel&gt; builder,
  }) : super(provider: provider, builder: builder);

  @override
  AddMachineViewModel createViewModel(useCase, output) =&gt; AddMachineViewModel(
      total: output.total.toString(),
      onAddNumber: (number) =&gt; _onAddNumber(useCase, number));

  void _onAddNumber(useCase, String number) {
    useCase.setInput&lt;AddMachineAddNumberInput&gt;(
        AddMachineAddNumberInput(int.parse(number)));
  }

  @override
  void onLayoutReady(context, AddMachineUseCase useCase) =&gt; useCase.onCreate();
}
</code></pre>
<p>To be able to use a specific Use Case, we had to include the name of the class in the generics declaration.</p>
<p>With the <strong>onLayoutReady</strong> override we are able to call any method on the use case the first time the UI is built.</p>
<p>If all these changes are correct and the new test passes, congratulations! You now have attached a custom Gateway to your feature!</p>


      </google-codelab-step>
    
      <google-codelab-step label="External Interface Layer" duration="10">
        <p>The final piece of the Framework is the most flexible one, since it work as a wrapper for any external dependency code from libraries and modules. If coded properly, they will protect you from dependencies migrations and version upgrades.</p>
<p class="image-container"><img alt="External Interface Components" src="img/a79555228fb3f4c6.png"></p>
<p>As usual, let&#39;s study the example first:</p>
<pre><code language="language-dart" class="language-dart">class TestInterface extends ExternalInterface&lt;TestRequest, TestResponse&gt; {
  TestInterface(GatewayProvider provider)
      : super([() =&gt; provider.getGateway(context)]);

  @override
  void handleRequest() {
    // For normal Gateways
    on&lt;FutureTestRequest&gt;(
      (request, send) async {
        await Future<void>.delayed(Duration(milliseconds: 100));
        send(Right(TestResponse(&#39;success&#39;)));
      },
    );

    // For WatcherGateways
    on&lt;StreamTestRequest&gt;(
      (request, send) async {
        final stream = Stream.periodic(
          Duration(milliseconds: 100),
          (count) =&gt; count,
        );

        final subscription = stream.listen(
          (count) =&gt; send(Right(TestResponse(count.toString()))),
        );

        await Future<void>.delayed(Duration(milliseconds: 500));
        subscription.cancel();
      },
    );
  }
}
</code></pre>
<p>First let&#39;s understand the constructor. It requires a list of Gateway references, which are normally retrieved from providers. During tests, you can add the object reference direcly.</p>
<p>When the External Interface gets created by its Provider, this connection will attach the object to the mechanism that the Gateway uses to send Requests.</p>
<p>The <strong>handleRequest</strong> method will have one or multiple calls of the <strong>on</strong> method, each one associated to a Request Type. These types must extend from the Response type specified on the generics class declaration.</p>
<p>Each of the <strong>on</strong> calls will send back an <em>Either</em> instance, where the <em>Right</em> value is a <strong>SuccessResponse</strong>, and the <em>Left</em> is a <strong>FailureResponse</strong>.</p>
<p>External Interfaces are meant to listen to groups of Requests that use the same dependency. Clean Framework has default implementations of external interfaces for Firebase, GraphQL and REST services, ready to be used in any application, you just need to create the providers using them.</p>
<h2 is-upgraded>Testing and Coding the External Interface</h2>
<p>For the final changes on our Add Machine app, we will move the code for the static number in the Gateway to the External Interface. There are no further chages on the current tests, but as an exercise you can add an integration test that confirms the last scenario by adding a way to navigate to the feature, pop out, then open it again to confirm the number is preserved.</p>
<p>This is the remaining code:</p>
<h3 is-upgraded>lib/features/add_machine/external_interface/add_machine_external_interface.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineExternalInterface
    extends ExternalInterface&lt;Request, AddMachineGetTotalResponse&gt; {
  int _savedNumber;

  AddMachineExternalInterface({
    required List&lt;GatewayConnection&gt; gatewayConnections,
    int number = 0,
  })  : _savedNumber = number,
        super(gatewayConnections);

  @override
  void handleRequest() {
    on&lt;AddMachineGetTotalRequest&gt;((request, send) {
      send(AddMachineGetTotalResponse(_savedNumber));
    });

    on&lt;AddMachineSetTotalRequest&gt;((request, send) {
      _savedNumber = request.number;
      send(AddMachineGetTotalResponse(_savedNumber));
    });
  }

  @override
  FailureResponse onError(Object error) {
    // left empty, enhance as an exercise later
    return UnknownFailureResponse();
  }
}
</code></pre>
<p>See how now we handle two types of request, one to just get the saved total, and the other to modify the total before sending the current value. This requires the creation of another Gateway and request, as follows:</p>
<h3 is-upgraded>lib/features/add_machine/external_interface/add_machine_set_total_gateway.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineSetTotalGateway extends Gateway&lt;
    AddMachineSetTotalOutput,
    AddMachineSetTotalRequest,
    AddMachineGetTotalResponse,
    AddMachineGetTotalInput&gt; {
  AddMachineSetTotalGateway({
    ProvidersContext? context,
    UseCaseProvider? provider,
    UseCase? useCase,
  }) : super(context: context, provider: provider, useCase: useCase);

  @override
  buildRequest(AddMachineSetTotalOutput output) {
    return AddMachineSetTotalRequest(output.number);
  }

  @override
  FailureInput onFailure(covariant FailureResponse failureResponse) {
    throw UnimplementedError();
  }

  @override
  onSuccess(covariant AddMachineGetTotalResponse response) {
    return AddMachineGetTotalInput(response.number);
  }
}

class AddMachineSetTotalRequest extends Request {
  final int number;

  AddMachineSetTotalRequest(this.number);
}
</code></pre>
<p>And here are the changes for the rest of components:</p>
<h3 is-upgraded>lib/features/add_machine/domain/add_machine_use_case.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachineUseCase extends UseCase&lt;AddMachineEntity&gt; {
  AddMachineUseCase()
      : super(entity: AddMachineEntity(0), outputFilters: {
          AddMachineUIOutput: (AddMachineEntity e) =&gt;
              AddMachineUIOutput(total: e.total),
        }) {
    onCreate();
  }

  void onAddNumber(int number) async {
    await request(AddMachineSetTotalOutput(number + entity.total),
        onSuccess: (AddMachineGetTotalInput input) {
      return AddMachineEntity(input.number);
    }, onFailure: (_) {
      return entity;
    });
  }

  void onCreate() async {
    await request(AddMachineGetTotalOutput(),
        onSuccess: (AddMachineGetTotalInput input) {
          return AddMachineEntity(input.number);
        },
        onFailure: (_) =&gt; entity);
  }
}
</code></pre>
<h3 is-upgraded>lib/features/add_machine/presentation/add_machine_presenter.dart</h3>
<pre><code language="language-dart" class="language-dart">class AddMachinePresenter extends Presenter&lt;AddMachineViewModel,
    AddMachineUIOutput, AddMachineUseCase&gt; {
  AddMachinePresenter({
    required UseCaseProvider provider,
    required PresenterBuilder&lt;AddMachineViewModel&gt; builder,
  }) : super(provider: provider, builder: builder);

  @override
  AddMachineViewModel createViewModel(useCase, output) =&gt; AddMachineViewModel(
      total: output.total.toString(),
      onAddNumber: (number) =&gt; _onAddNumber(useCase, number));

  void _onAddNumber(AddMachineUseCase useCase, String number) {
    useCase.onAddNumber(int.parse(number));
  }

  @override
  void onLayoutReady(context, AddMachineUseCase useCase) =&gt; useCase.onCreate();
}
</code></pre>
<p>The main change is that now the Use Case uses a specific method to handle the request to change the saved number, instead of using an input filter.</p>
<p>And finally, some minor corrections to all the tests, just to enable all the providers:</p>
<pre><code language="language-dart" class="language-dart">final context = ProvidersContext();
late UseCaseProvider addMachineUseCaseProvider;
late GatewayProvider getTotalGatewayProvider;
late GatewayProvider setTotalGatewayProvider;
late ExternalInterfaceProvider externalInterfaceProvider;

void main() {
  final sumTotalWidget = find.byKey(Key(&#39;SumTotalWidget&#39;));

  void setup() {
    addMachineUseCaseProvider = UseCaseProvider((_) =&gt; AddMachineUseCase());
    getTotalGatewayProvider = GatewayProvider&lt;AddMachineGetTotalGateway&gt;((_) =&gt;
        AddMachineGetTotalGateway(
            context: context, provider: addMachineUseCaseProvider));
    setTotalGatewayProvider = GatewayProvider&lt;AddMachineSetTotalGateway&gt;((_) =&gt;
        AddMachineSetTotalGateway(
            context: context, provider: addMachineUseCaseProvider));

    externalInterfaceProvider = ExternalInterfaceProvider((_) =&gt;
        AddMachineExternalInterface(
            gatewayConnections: &lt;GatewayConnection&lt;Gateway&gt;&gt;[
              () =&gt; getTotalGatewayProvider.getGateway(context),
              () =&gt; setTotalGatewayProvider.getGateway(context),
            ]));
    getTotalGatewayProvider.getGateway(context);
    setTotalGatewayProvider.getGateway(context);
    externalInterfaceProvider.getExternalInterface(context);
  }

  /// Given I have navigated to the Add Machine feature
  /// Then I will see the Add Machine screen
  /// And the total shown will be 0.
  uiTest(
    &#39;AddMachineUI unit test - Scenario 1&#39;,
    context: context,
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    setup: setup,
    verify: (tester) async {
      expect(find.text(&#39;Add Machine&#39;), findsOneWidget);

      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;0&#39;)),
          findsOneWidget);
    },
  );

  /// Given I opened the Add Machine feature
  /// When I write a number on the number field
  /// And I press the &#34;Add&#34; button
  /// Then the total shown will be the entered number.
  uiTest(
    &#39;AddMachineUI unit test - Scenario 2&#39;,
    context: context,
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    setup: setup,
    verify: (tester) async {
      final numberField = find.byKey(Key(&#39;NumberField&#39;));
      expect(numberField, findsOneWidget);

      await tester.enterText(numberField, &#39;15&#39;);

      final addButton = find.byKey(Key(&#39;AddButton&#39;));
      expect(addButton, findsOneWidget);

      await tester.tap(addButton);
      await tester.pumpAndSettle();
      await tester.pumpAndSettle();

      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;15&#39;)),
          findsOneWidget);
    },
  );

  /// Given I have entered a number on the Add Machine feature
  /// When I write another number and press &#34;Add&#34;
  /// Then the total shown will be the sum of both numbers.
  uiTest(
    &#39;AddMachineUI unit test - Scenario 3&#39;,
    context: context,
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    setup: setup,
    verify: (tester) async {
      final numberField = find.byKey(Key(&#39;NumberField&#39;));
      expect(numberField, findsOneWidget);

      await tester.enterText(numberField, &#39;15&#39;);

      final addButton = find.byKey(Key(&#39;AddButton&#39;));
      expect(addButton, findsOneWidget);

      await tester.tap(addButton);
      await tester.pumpAndSettle();

      expect(sumTotalWidget, findsOneWidget);

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;15&#39;)),
          findsOneWidget);

      await tester.enterText(numberField, &#39;7&#39;);
      await tester.tap(addButton);
      await tester.pumpAndSettle();

      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;22&#39;)),
          findsOneWidget);
    },
  );

  /// Given I have added one or more numbers on the Add Machine feature
  /// When I navigate away and open the feature again
  /// Then the total shown is the previous total that was shown.
  uiTest(
    &#39;AddMachineUI unit test - Scenario 4&#39;,
    context: context,
    builder: () =&gt; AddMachineUI(provider: addMachineUseCaseProvider),
    setup: () {
      setup();

      final gateway = setTotalGatewayProvider.getGateway(context);

      // We add a pre-existent request, so by the time the UI is build,
      // the use case already has this value
      gateway.transport(AddMachineSetTotalRequest(740));
    },
    verify: (tester) async {
      expect(find.descendant(of: sumTotalWidget, matching: find.text(&#39;740&#39;)),
          findsOneWidget);
    },
  );
}
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
